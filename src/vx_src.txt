<start of characterTrim.js> /** * Functions for trimming files based on character ranges */ /** * Processes content by applying character range trimming/cutting * * @param {string} content - The file content to process * @param {object} options - Trim/cut options * @returns {string} - The processed content */ function processCharacterRanges(content, options) { let result = content; // Process trim ranges - only keep characters within these ranges if (options.trim && options.trim.length > 0) { // Convert content to array for easier manipulation const contentArray = [...content]; let newContent = []; // Process each trim range for (const range of options.trim) { const [start, end] = parseRange(range, content.length); if (start !== null && end !== null) { // Add characters from this range to the result newContent.push(...contentArray.slice(start, end + 1)); } } result = newContent.join(''); } // Process cut ranges - remove characters within these ranges if (options.cut && options.cut.length > 0) { // Convert content to array for easier manipulation const contentArray = [...result]; let newContent = [...contentArray]; // Process each cut range (in reverse to maintain indices) for (const range of options.cut.sort((a, b) => { const [aStart] = parseRange(a, result.length); const [bStart] = parseRange(b, result.length); return bStart - aStart; // Sort in descending order })) { const [start, end] = parseRange(range, result.length); if (start !== null && end !== null) { // Remove characters from this range newContent.splice(start, end - start + 1); } } result = newContent.join(''); } return result; } /** * Parse a range string into start and end indices * * @param {string} rangeStr - Range string in format "start-end" * @param {number} contentLength - Length of the content for handling wildcards * @returns {Array} - [startIndex, endIndex] or [null, null] if invalid */ function parseRange(rangeStr, contentLength) { // Clean up any quotes or parentheses that might be in the range string const cleanRange = rangeStr.replace(/['"()]/g, ''); const match = cleanRange.match(/^(s|\*|\d+)-(e|\*|\d+)$/); if (!match) return [null, null]; let [_, startStr, endStr] = match; // Convert wildcard or special values to actual value const start = startStr === '*' || startStr === 's' ? 0 : parseInt(startStr, 10); const end = endStr === '*' || endStr === 'e' ? contentLength - 1 : parseInt(endStr, 10); // Validate range if (isNaN(start) || isNaN(end) || start < 0 || end >= contentLength || start > end) { console.warn(`Invalid range: ${cleanRange} (converted to ${start}-${end}, content length: ${contentLength})`); return [null, null]; } return [start, end]; } /** * Extract and parse character range options from command line arguments * * @param {object} options - Command line options * @returns {object} - Parsed trim and cut options */ function extractCharacterRangeOptions(options) { const result = { trim: [], cut: [] }; if (options.trim) { // Handle trim ranges const trimRanges = Array.isArray(options.trim) ? options.trim : [options.trim]; result.trim = trimRanges; } if (options.cut) { // Handle cut ranges const cutRanges = Array.isArray(options.cut) ? options.cut : [options.cut]; result.cut = cutRanges; } return result; } export { processCharacterRanges, extractCharacterRangeOptions }; <end of characterTrim.js> <start of commentRemover.js> function removeComments(content, fileExtension) { switch (fileExtension) { case '.js': case '.ts': return content.replace(/\/\/.*|\/\*[\s\S]*?\*\//g, ''); case '.py': return content.replace(/#.*|""".*?"""|\'\'\'.*?\'\'\'/gs, ''); case '.html': case '.xml': return content.replace(/<!--.*?-->/gs, ''); case '.css': return content.replace(/\/\*[\s\S]*?\*\//g, ''); case '.sh': return content.replace(/#.*/g, ''); case '.rb': return content.replace(/#.*|=begin.*=end/gs, ''); default: return content; } } export { removeComments }; <end of commentRemover.js> <start of fileProcessor.js> import fs from 'fs-extra'; import path from 'path'; import glob from 'glob'; import { removeComments } from './commentRemover.js'; import { scrubSensitiveInfo } from './privacyFilter.js'; import { processCharacterRanges, extractCharacterRangeOptions } from './characterTrim.js'; import chokidar from 'chokidar'; async function processFiles(options) { let filesToProcess = []; const defaultExcludes = ['node_modules/**']; if (options.files) { filesToProcess = options.files.filter(file => !file.startsWith('vx_')); } else { const excludePatterns = options.force ? options.exclude || [] : [...defaultExcludes, ...(options.exclude || [])]; filesToProcess = glob.sync('**/*.{js,py,html,css,txt}', { ignore: excludePatterns }).filter(file => !file.startsWith('vx_')); } // Extract character range options const rangeOptions = extractCharacterRangeOptions(options); let combinedContent = ''; for (const file of filesToProcess) { const content = await fs.readFile(file, 'utf-8'); let processedContent = content; // Apply character range trimming/cutting if (rangeOptions.trim.length > 0 || rangeOptions.cut.length > 0) { processedContent = processCharacterRanges(processedContent, rangeOptions); } if (options.rc) { processedContent = removeComments(processedContent, path.extname(file)); } if (options.rp) { processedContent = scrubSensitiveInfo(processedContent); } // Compress the content by removing unnecessary spaces and newlines processedContent = processedContent.replace(/\s+/g, ' ').trim(); // Add markers for the start and end of each file's content const startMarker = `<start of ${file}>`; const endMarker = `<end of ${file}>`; combinedContent += options.separate ? `\n${startMarker}\n${processedContent}\n${endMarker}\n` : `${startMarker}\n${processedContent}\n${endMarker}\n`; } // Compress the final combined content combinedContent = combinedContent.replace(/\s+/g, ' ').trim(); // Determine the output file name const outputFileName = options.files && options.files.length > 0 ? `vx_${path.basename(options.files[0])}.txt` : `vx_${path.basename(process.cwd())}.txt`; const outputFile = path.join(process.cwd(), outputFileName); await fs.writeFile(outputFile, combinedContent); const { default: chalk } = await import('chalk'); console.log(chalk.green(`Combined content written to ${outputFile}`)); if (options.monitor) { const watcher = chokidar.watch(filesToProcess); watcher.on('change', async (filePath) => { const content = await fs.readFile(filePath, 'utf-8'); let processedContent = content; // Apply character range trimming/cutting if (rangeOptions.trim.length > 0 || rangeOptions.cut.length > 0) { processedContent = processCharacterRanges(processedContent, rangeOptions); } if (options.rc) { processedContent = removeComments(processedContent, path.extname(filePath)); } if (options.rp) { processedContent = scrubSensitiveInfo(processedContent); } // Compress the content by removing unnecessary spaces and newlines processedContent = processedContent.replace(/\s+/g, ' ').trim(); // Add markers for the start and end of each file's content const startMarker = `<start of ${filePath}>`; const endMarker = `<end of ${filePath}>`; combinedContent = combinedContent.replace(new RegExp(`${startMarker}.*${endMarker}`, 's'), `${startMarker}\n${processedContent}\n${endMarker}`); // Compress the final combined content combinedContent = combinedContent.replace(/\s+/g, ' ').trim(); await fs.writeFile(outputFile, combinedContent); console.log(chalk.green(`Updated ${outputFile} due to changes in ${filePath}`)); }); } } export { processFiles }; <end of fileProcessor.js> <start of fileSupport.js> // src/fileSupport.js /** * File type support information and utilities */ const fileTypeSupport = { // Full support - detailed parsing and advanced features fullSupport: [ '.js', '.jsx', '.ts', '.tsx', // JavaScript/TypeScript '.py', // Python '.html', '.htm', // HTML '.css', '.scss', // CSS '.md', // Markdown '.json', // JSON ], // Partial support - basic parsing and features partialSupport: [ '.rb', // Ruby '.go', // Go '.swift', // Swift '.kt', '.kts', // Kotlin '.java', // Java '.c', '.cpp', '.h', '.hpp', // C/C++ '.php', // PHP '.rs', // Rust '.sh', '.bash', // Shell scripts '.xml', '.svg', // XML formats '.yaml', '.yml', // YAML '.sql', // SQL '.less', // Less CSS ], // Basic support - minimal processing basicSupport: [ '.txt', // Plain text '.csv', // CSV '.ini', // INI config '.conf', // Config files '.toml', // TOML '.env', // Environment variables '.gitignore', // Git ignore '.dockerignore', // Docker ignore '.ps1', // PowerShell '.pl', '.pm', // Perl '.r', // R '.elm', // Elm '.lua', // Lua '.dart', // Dart '.ex', '.exs', // Elixir '.hs', // Haskell '.fs', '.fsx', // F# ], // File categories for organization categories: { 'frontend': ['.js', '.jsx', '.ts', '.tsx', '.html', '.css', '.scss', '.less', '.svg'], 'backend': ['.js', '.ts', '.py', '.rb', '.go', '.java', '.php', '.cs', '.rs'], 'config': ['.json', '.yaml', '.yml', '.toml', '.ini', '.conf', '.env'], 'documentation': ['.md', '.txt', '.rst', '.adoc'], 'data': ['.json', '.csv', '.xml', '.yaml', '.yml'], 'script': ['.sh', '.bash', '.ps1', '.bat', '.cmd'] }, /** * Checks if a file extension has full support * @param {string} extension - File extension * @returns {boolean} - Whether the extension has full support */ hasFullSupport(extension) { return this.fullSupport.includes(extension.toLowerCase()); }, /** * Checks if a file extension has at least partial support * @param {string} extension - File extension * @returns {boolean} - Whether the extension has at least partial support */ hasPartialSupport(extension) { return this.partialSupport.includes(extension.toLowerCase()); }, /** * Checks if a file extension has any level of support * @param {string} extension - File extension * @returns {boolean} - Whether the extension has any support */ isSupported(extension) { extension = extension.toLowerCase(); return this.fullSupport.includes(extension) || this.partialSupport.includes(extension) || this.basicSupport.includes(extension); }, /** * Gets the support level for a file extension * @param {string} extension - File extension * @returns {string} - Support level (full, partial, basic, or unsupported) */ getSupportLevel(extension) { extension = extension.toLowerCase(); if (this.fullSupport.includes(extension)) return 'full'; if (this.partialSupport.includes(extension)) return 'partial'; if (this.basicSupport.includes(extension)) return 'basic'; return 'unsupported'; } }; /** * Gets the category of a file based on its extension * @param {string} extension - File extension * @returns {string} - Category of the file */ function getFileCategory(extension) { extension = extension.toLowerCase(); for (const [category, extensions] of Object.entries(fileTypeSupport.categories)) { if (extensions.includes(extension)) { return category; } } return 'other'; } /** * Checks if a file is binary (not text) * @param {string} filePath - Path to the file * @returns {Promise<boolean>} - Whether the file is binary */ async function isBinaryFile(filePath) { try { const { default: isBinary } = await import('is-binary-file'); return await isBinary(filePath); } catch (error) { // Fallback to extension-based check if module not available const binaryExtensions = [ '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.tif', '.tiff', '.pdf', '.doc', '.docx', '.ppt', '.pptx', '.xls', '.xlsx', '.zip', '.tar', '.gz', '.7z', '.rar', '.exe', '.dll', '.so', '.mp3', '.mp4', '.avi', '.mov', '.wav', '.ogg', '.flac', '.ttf', '.otf', '.woff', '.woff2' ]; const extension = require('path').extname(filePath).toLowerCase(); return binaryExtensions.includes(extension); } } /** * Gets language-specific parser options for a file * @param {string} extension - File extension * @returns {Object} - Parser options */ function getParserOptions(extension) { extension = extension.toLowerCase(); // Default options for all parsers const defaultOptions = { removeComments: true, preserveDocstrings: false }; // Language-specific options const languageOptions = { '.js': { parser: 'babel', plugins: ['jsx'] }, '.jsx': { parser: 'babel', plugins: ['jsx'] }, '.ts': { parser: 'typescript' }, '.tsx': { parser: 'typescript', plugins: ['jsx'] }, '.py': { parser: 'python', keepDocstrings: true }, '.html': { parser: 'html' }, '.css': { parser: 'css' }, '.scss': { parser: 'scss' }, '.md': { parser: 'markdown' }, '.json': { parser: 'json' }, '.rb': { parser: 'ruby' }, '.go': { parser: 'go' }, '.swift': { parser: 'swift' }, '.kt': { parser: 'kotlin' }, '.java': { parser: 'java' }, '.php': { parser: 'php' } }; return { ...defaultOptions, ...(languageOptions[extension] || {}) }; } export { fileTypeSupport, getFileCategory, isBinaryFile, getParserOptions }; <end of fileSupport.js> <start of index.js> import { program } from 'commander'; import { processFiles } from './fileProcessor.js'; program .name('vx') .description('VibEx CLI for preparing code for AI analysis') .version('0.1.0'); program .command('combine') .alias('c') .description('Combine files for AI analysis') .option('-f, --files <files...>', 'Specify files to include') .option('-s, --separate', 'Keep files visually separated') .option('-x, --exclude <files...>', 'Files to exclude') .option('--rc', 'Remove comments') .option('--rp', 'Remove private information') .option('-mx, --monitor', 'Monitor files for changes') .option('--force', 'Force inclusion of sensitive folders') .option('--trim <ranges...>', 'Only include characters in specified ranges (format: "start-end", use "s" for start, "e" for end)') .option('--cut <ranges...>', 'Exclude characters in specified ranges (format: "start-end", use "s" for start, "e" for end)') .action((options) => { processFiles(options); }); program.parse(); <end of index.js> <start of privacyFilter.js> function scrubSensitiveInfo(content) { content = content.replace(/[A-Za-z0-9_-]{20,}/g, 'API_KEY'); // API keys content = content.replace(/\b\d{3}[-.]?\d{2}[-.]?\d{4}\b/g, '+123456789'); // Phone numbers content = content.replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g, 'example@gmail.com'); // Emails content = content.replace(/\b\d{5}-\d{4}|\d{3}-\d{2}-\d{4}\b/g, '11111'); // Numeric codes content = content.replace(/\b[A-Z][a-z]+(?: [A-Z][a-z]+)*\b/g, 'FIRST_NAME'); // Names return content; } export { scrubSensitiveInfo }; <end of privacyFilter.js> <start of utils.js> // src/utils.js // Add utility functions here as needed <end of utils.js>