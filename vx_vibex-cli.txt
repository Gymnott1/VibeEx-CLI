<start of bin/vx.js> #!/usr/bin/env node import '../src/index.js'; <end of bin/vx.js> <start of src/characterTrim.js> function processCharacterRanges(content, options) { let result = content; if (options.trim && options.trim.length > 0) { const contentArray = [...content]; let newContent = []; for (const range of options.trim) { const [start, end] = parseRange(range, content.length); if (start !== null && end !== null) { newContent.push(...contentArray.slice(start, end + 1)); } } result = newContent.join(''); } if (options.cut && options.cut.length > 0) { const contentArray = [...result]; let newContent = [...contentArray]; for (const range of options.cut.sort((a, b) => { const [aStart] = parseRange(a, result.length); const [bStart] = parseRange(b, result.length); return bStart - aStart; })) { const [start, end] = parseRange(range, result.length); if (start !== null && end !== null) { newContent.splice(start, end - start + 1); } } result = newContent.join(''); } return result; } function parseRange(rangeStr, contentLength) { const match = rangeStr.match(/^(\*|\d+)-(\*|\d+)$/); if (!match) return [null, null]; let [_, startStr, endStr] = match; const start = startStr === '*' ? 0 : parseInt(startStr, 10); const end = endStr === '*' ? contentLength - 1 : parseInt(endStr, 10); if (isNaN(start) || isNaN(end) || start < 0 || end >= contentLength || start > end) { return [null, null]; } return [start, end]; } function extractCharacterRangeOptions(options) { const result = { trim: [], cut: [] }; if (options.trim) { const trimRanges = Array.isArray(options.trim) ? options.trim : [options.trim]; result.trim = trimRanges.map(range => { const match = range.match(/\(([^)]+)\)/); return match ? match[1] : range; }); } if (options.cut) { const cutRanges = Array.isArray(options.cut) ? options.cut : [options.cut]; result.cut = cutRanges.map(range => { const match = range.match(/\(([^)]+)\)/); return match ? match[1] : range; }); } return result; } export { processCharacterRanges, extractCharacterRangeOptions }; <end of src/characterTrim.js> <start of src/commentRemover.js> function removeComments(content, fileExtension) { switch (fileExtension) { case '.js': case '.ts': return content.replace(/\/\/.*|\/\*[\s\S]*?\*\ case '.py': return content.replace(/#.*|""".*?"""|\'\'\'.*?\'\'\'/gs, ''); case '.html': case '.xml': return content.replace(/<!--.*?-->/gs, ''); case '.css': return content.replace(/\/\*[\s\S]*?\*\ case '.sh': return content.replace(/#.*/g, ''); case '.rb': return content.replace(/#.*|=begin.*=end/gs, ''); default: return content; } } export { removeComments }; <end of src/commentRemover.js> <start of src/fileProcessor.js> import fs from 'fs-extra'; import path from 'path'; import glob from 'glob'; import { removeComments } from './commentRemover.js'; import { scrubSensitiveInfo } from './privacyFilter.js'; import { processCharacterRanges, extractCharacterRangeOptions } from './characterTrim.js'; import chokidar from 'chokidar'; async function processFiles(options) { let filesToProcess = []; const defaultExcludes = ['node_modules*.{js,py,html,css,txt}', { ignore: excludePatterns }).filter(file => !file.startsWith('vx_')); } const rangeOptions = extractCharacterRangeOptions(options); let combinedContent = ''; for (const file of filesToProcess) { const content = await fs.readFile(file, 'utf-8'); let processedContent = content; if (rangeOptions.trim.length > 0 || rangeOptions.cut.length > 0) { processedContent = processCharacterRanges(processedContent, rangeOptions); } if (options.rc) { processedContent = removeComments(processedContent, path.extname(file)); } if (options.rp) { processedContent = scrubSensitiveInfo(processedContent); } processedContent = processedContent.replace(/\s+/g, ' ').trim(); const startMarker = `<start of ${file}>`; const endMarker = `<end of ${file}>`; combinedContent += options.separate ? `\n${startMarker}\n${processedContent}\n${endMarker}\n` : `${startMarker}\n${processedContent}\n${endMarker}\n`; } combinedContent = combinedContent.replace(/\s+/g, ' ').trim(); const outputFileName = options.files && options.files.length > 0 ? `vx_${path.basename(options.files[0])}.txt` : `vx_${path.basename(process.cwd())}.txt`; const outputFile = path.join(process.cwd(), outputFileName); await fs.writeFile(outputFile, combinedContent); const { default: chalk } = await import('chalk'); console.log(chalk.green(`Combined content written to ${outputFile}`)); if (options.monitor) { const watcher = chokidar.watch(filesToProcess); watcher.on('change', async (filePath) => { const content = await fs.readFile(filePath, 'utf-8'); let processedContent = content; if (rangeOptions.trim.length > 0 || rangeOptions.cut.length > 0) { processedContent = processCharacterRanges(processedContent, rangeOptions); } if (options.rc) { processedContent = removeComments(processedContent, path.extname(filePath)); } if (options.rp) { processedContent = scrubSensitiveInfo(processedContent); } processedContent = processedContent.replace(/\s+/g, ' ').trim(); const startMarker = `<start of ${filePath}>`; const endMarker = `<end of ${filePath}>`; combinedContent = combinedContent.replace(new RegExp(`${startMarker}.*${endMarker}`, 's'), `${startMarker}\n${processedContent}\n${endMarker}`); combinedContent = combinedContent.replace(/\s+/g, ' ').trim(); await fs.writeFile(outputFile, combinedContent); console.log(chalk.green(`Updated ${outputFile} due to changes in ${filePath}`)); }); } } export { processFiles }; <end of src/fileProcessor.js> <start of src/fileSupport.js> const fileTypeSupport = { fullSupport: [ '.js', '.jsx', '.ts', '.tsx', '.py', '.html', '.htm', '.css', '.scss', '.md', '.json', ], partialSupport: [ '.rb', '.go', '.swift', '.kt', '.kts', '.java', '.c', '.cpp', '.h', '.hpp', '.php', '.rs', '.sh', '.bash', '.xml', '.svg', '.yaml', '.yml', '.sql', '.less', ], basicSupport: [ '.txt', '.csv', '.ini', '.conf', '.toml', '.env', '.gitignore', '.dockerignore', '.ps1', '.pl', '.pm', '.r', '.elm', '.lua', '.dart', '.ex', '.exs', '.hs', '.fs', '.fsx', ], categories: { 'frontend': ['.js', '.jsx', '.ts', '.tsx', '.html', '.css', '.scss', '.less', '.svg'], 'backend': ['.js', '.ts', '.py', '.rb', '.go', '.java', '.php', '.cs', '.rs'], 'config': ['.json', '.yaml', '.yml', '.toml', '.ini', '.conf', '.env'], 'documentation': ['.md', '.txt', '.rst', '.adoc'], 'data': ['.json', '.csv', '.xml', '.yaml', '.yml'], 'script': ['.sh', '.bash', '.ps1', '.bat', '.cmd'] }, hasFullSupport(extension) { return this.fullSupport.includes(extension.toLowerCase()); }, hasPartialSupport(extension) { return this.partialSupport.includes(extension.toLowerCase()); }, isSupported(extension) { extension = extension.toLowerCase(); return this.fullSupport.includes(extension) || this.partialSupport.includes(extension) || this.basicSupport.includes(extension); }, getSupportLevel(extension) { extension = extension.toLowerCase(); if (this.fullSupport.includes(extension)) return 'full'; if (this.partialSupport.includes(extension)) return 'partial'; if (this.basicSupport.includes(extension)) return 'basic'; return 'unsupported'; } }; function getFileCategory(extension) { extension = extension.toLowerCase(); for (const [category, extensions] of Object.entries(fileTypeSupport.categories)) { if (extensions.includes(extension)) { return category; } } return 'other'; } async function isBinaryFile(filePath) { try { const { default: isBinary } = await import('is-binary-file'); return await isBinary(filePath); } catch (error) { const binaryExtensions = [ '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.tif', '.tiff', '.pdf', '.doc', '.docx', '.ppt', '.pptx', '.xls', '.xlsx', '.zip', '.tar', '.gz', '.7z', '.rar', '.exe', '.dll', '.so', '.mp3', '.mp4', '.avi', '.mov', '.wav', '.ogg', '.flac', '.ttf', '.otf', '.woff', '.woff2' ]; const extension = require('path').extname(filePath).toLowerCase(); return binaryExtensions.includes(extension); } } function getParserOptions(extension) { extension = extension.toLowerCase(); const defaultOptions = { removeComments: true, preserveDocstrings: false }; const languageOptions = { '.js': { parser: 'babel', plugins: ['jsx'] }, '.jsx': { parser: 'babel', plugins: ['jsx'] }, '.ts': { parser: 'typescript' }, '.tsx': { parser: 'typescript', plugins: ['jsx'] }, '.py': { parser: 'python', keepDocstrings: true }, '.html': { parser: 'html' }, '.css': { parser: 'css' }, '.scss': { parser: 'scss' }, '.md': { parser: 'markdown' }, '.json': { parser: 'json' }, '.rb': { parser: 'ruby' }, '.go': { parser: 'go' }, '.swift': { parser: 'swift' }, '.kt': { parser: 'kotlin' }, '.java': { parser: 'java' }, '.php': { parser: 'php' } }; return { ...defaultOptions, ...(languageOptions[extension] || {}) }; } export { fileTypeSupport, getFileCategory, isBinaryFile, getParserOptions }; <end of src/fileSupport.js> <start of src/index.js> import { program } from 'commander'; import { processFiles } from './fileProcessor.js'; program .name('vx') .description('VibEx CLI for preparing code for AI analysis') .version('0.1.0'); program .command('combine') .alias('c') .description('Combine files for AI analysis') .option('-f, --files <files...>', 'Specify files to include') .option('-s, --separate', 'Keep files visually separated') .option('-x, --exclude <files...>', 'Files to exclude') .option('--rc', 'Remove comments') .option('--rp', 'Remove private information') .option('-mx, --monitor', 'Monitor files for changes') .option('--force', 'Force inclusion of sensitive folders') .option('--trim <ranges...>', 'Only include characters in specified ranges (format: (start-end))') .option('--cut <ranges...>', 'Exclude characters in specified ranges (format: (start-end))') .action((options) => { processFiles(options); }); program.parse(); <end of src/index.js> <start of src/privacyFilter.js> function scrubSensitiveInfo(content) { content = content.replace(/[A-Za-z0-9_-]{20,}/g, 'API_KEY'); content = content.replace(/\b\d{3}[-.]?\d{2}[-.]?\d{4}\b/g, '+123456789'); content = content.replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g, 'example@gmail.com'); content = content.replace(/\b\d{5}-\d{4}|\d{3}-\d{2}-\d{4}\b/g, '11111'); content = content.replace(/\b[A-Z][a-z]+(?: [A-Z][a-z]+)*\b/g, 'FIRST_NAME'); return content; } export { scrubSensitiveInfo }; <end of src/privacyFilter.js> <start of src/utils.js> <end of src/utils.js>